model sistemaCoches

-------------- Enumerations ------------
-------------- Classes ------------------ 

enum TipoRevision { Mantenimiento, Reparacion }

class Clock 
  attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    resolution: Integer init = 1 
  operations
    tick() 

    run (n:Integer)
end

abstract class ActiveObject -- real-time objects 
  operations
    tick()
end

association Time between 
  Clock [1] role clock
  ActiveObject [*] role ao ordered
end

class Coche < ActiveObject
  attributes
    fechaMatriculacion : Integer
    kmRecorridos : Integer
    enGarantia : Boolean
    necesitaMantenimiento : Boolean --derive : self.Clock.NOW - self.fechaMatriculacion >= 4 and self.Revision
    speed : Real init: 5
    position : Real init: 0
    isMoving : Boolean init: false
  operations
    accelerate() 
      begin 
        self.speed := self.speed + 1
      end
      post IncreasSpeed: self.speed = self.speed@pre + 1
    startMoving()
      begin
        self.isMoving := true
      end 
      pre isNotMoving : not self.isMoving
      post Moving : self.isMoving
    stopMoving()
      begin
        self.isMoving := false
      end
      pre isMoving : self.isMoving
      post notMoving : not self.isMoving
    tick()
      begin 
       if self.isMoving then
        self.position := self.position + self.speed*self.clock.resolution
      end;
    end
    post carMoved : self.isMoving@pre implies
                    self.position = self.position@pre + self.speed*self.clock.resolution


end

class Ciudad
  attributes
    nombre : String
    poblacion : Integer
end

associationclass Camino between    -- CiudadOrigen y CiudadFinal, creo que deberemos realizar 2 caminos por cada 2 ciudades
    Ciudad [1] role ciudadOrigen -- Esto es para facilitar el modelador
    Ciudad [1] role ciudadFinal
  attributes
    distancia : Integer
end

class Viaje
  attributes
    fechaSalida : Integer
    fechaLlegada : Integer
end

associationclass Revision between
    Taller [0..*] role tallerCoche
    Coche [0..*] role vehiculo
  attributes
    fechaInicio : Integer
    fechaFin : Integer
    tipoRevision : TipoRevision
end 


class Taller
end -- chatgpt dice que se pone así una relación sin atirbutos

class TallerOficial < Taller
  attributes
    tiempoGarantia : Integer
end

class TallerNoOficial < Taller
end
-------------- End of classes ------------------

-------------- Relationships ------------------
association EstOficial between
    TallerOficial [0..1] role tallerOficial
    Ciudad [1] role ciudadOficial
end

association EstaNoOficial between
    TallerNoOficial [0..*] role ciudadTallerNoOficial
    Ciudad [1] role ciudadNoOficial
end

association Ubicado between
    Coche [0..*] role coche
    Ciudad [0..1] role ciudad
end

association Arreglando between
    Coche [0..*] role cocheArreglando
    Taller [0..*] role tallerReparando
end

association Viajado between
    Coche [1]
    Viaje [0..*]
end

association ViajeCamino between
    Camino [1]
    Viaje [0..*]
end

-------------- End of relationships ------------------
------------- Invariants -------------

constraints
-- 1
context Camino
  inv distanciaCiudadMayorQueCinco:
    self.distancia >= 5



-- 3
context TallerNoOficial
    ---
    -- [Texto que describe el invariante]
    ---
    -- Si está en un taller, el coche y el taller están en la misma ciudad
    inv CocheYCiudadMismaQueTalleNoOficial:
        self.cocheArreglando->isEmpty() or
            self.cocheArreglando->forAll(coche | coche.ciudad = self.ciudadNoOficial)

context TallerOficial
    ---
    -- [Texto que describe el invariante]
    ---
    inv CocheYCiudadMismaQueTalleOficial:
        self.cocheArreglando->isEmpty() or
            self.cocheArreglando->forAll(coche | coche.ciudad = self.ciudadOficial)

--  4
--Todas las revisiones deben tener lugar después de que el coche se matriculase
context Revision
    ---
    -- [Texto que describe el invariante]
    ---
    inv revisionAfterRegistration:
      self.vehiculo.fechaMatriculacion < self.fechaInicio


-- 8
--Si el coche está realizando actualmente algún viaje, dicho
--viaje únicamente tendrá fecha de salida, pero no de llegada.
context Viaje
    ---
    -- [Texto que describe el invariante]
    ---
    inv viajeEnCurso:
      self.coche.isMoving implies self.fechaLlegada.isUndefined()

-- 9
--Un coche se encontrará en todo momento bien realizando un viaje determinado o bien en
--una ciudad.
context Coche
    ---
    -- [Texto que describe el invariante]
    ---
    inv cocheEnViajeOCiudad:
      (self.viaje->notEmpty() implies self.ciudad.isUndefined()) and
      (self.ciudad.isDefined() implies self.viaje->isEmpty())

-- 10
--Si el coche ha completado al menos un viaje y no se encuentra viajando, entonces debe
--encontrarse en la ciudad a la que llegó en su último viaje.
-- ESTA INVARIANTE ESTÁ CHUNGA, CREO QUE HAY QUE MEZCLAR CAMINO Y VIAJE EN UNO

-- 11
-- Dos viajes no pueden solaparse en el tiempo, es decir, un viaje debe ocurrir siempre 
-- después de otro, pudiendo la fecha de llegada de un viaje coincidir con la fecha de salida 
-- del siguiente. 
context Coche
  inv viajesNoSeSolapan:
  (self.viaje -> size() >= 2) implies (self.viaje-> forAll(v1,v2 | v1 <> v2 implies (
	(v1.fechaLlegada <= v2.fechaSalida)
        	)
	)
    )
-- Esto comprueba del listado de viajes, con cada viaje, si se cumplen los invariantes bien
--de v1 comprueba con v2, v3,v4,v5,v6,v7... su fecha de fin sea anterior
-- a la fecha de inicio del viaje v(i).
-- v1 <> v2 evita duplicadas
-- suponemos que los viajes estan ordenados, es decir, que v1 ocurre antes que v2


-- 12 

-- 14 ESTE NO ES UN INVARIANTE CREO
-------------- End of invariants ------------------

