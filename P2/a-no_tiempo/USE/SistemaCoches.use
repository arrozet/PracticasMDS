model sistemaCoches

-------------- Enumerations ------------
enum TipoRevision { reparacion, mantenimiento}
-------------- End of enumerations ------------

-------------- Classes ------------------ 
-- ANOTACION PARA TODOS, SOLUCION A TODOS LOS PROBLEMAS: para saber si un coche esta de viaje o no, buscamos en el ulitmo viaje de 
-- la lista de viajes del coche, si fecha de llegada esta definido 
-- EJEMPLO: context Coche
-- self.viajeCoche->sortedBy(r | r.fechaLlegada)->last().fechaLlegada.isUndefined()

class Clock 
  attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    --resolution: Integer init = 1 
end

class Coche
  attributes
    fechaMatriculacion : Integer
    -- esto es derive (apartado 13) - SE USA CLOCK
    kmRecorridos : Integer derive : 
      self.viajeCoche->select(v | v.fechaLlegada.isDefined())->collect(v | v.recorridoViaje.numKm)->sum()
    -- esto es derive (apartado 15)
    enGarantia : Boolean 
    -- esto es derive (apartado 16) - SE USA CLOCK
    necesitaMantenimiento : Boolean
end

class Ciudad
  attributes
    nombre : String
    poblacion : Integer
end

-- PREGUNTAR AL PROFESOR SOBRE EL COMENTARIO DE ABAJO
associationclass Recorrido between    -- CiudadOrigen y CiudadFinal, creo que deberemos realizar 2 caminos por cada 2 ciudades
    Ciudad [0..*] role ciudadOrigen -- Esto es para facilitar el modelador
    Ciudad [0..*] role ciudadFinal
  attributes
    numKm : Integer
end

class Viaje
  attributes
    fechaSalida : Integer
    fechaLlegada : Integer
end

class Revision
  attributes
    fechaInicio : Integer
    fechaFin : Integer
    tipoRevision : TipoRevision
end 

class Taller
end 

class TallerOficial < Taller
  attributes
    tiempoGarantia : Integer
end

-------------- End of classes ------------------

-------------- Relationships ------------------
composition UbicacionTaller between
    Ciudad [1] role ciudadTaller
    Taller [0..*] role tallerCiudad
end

association Ubicado between
    Coche [0..*] role cocheEstacionado
    Ciudad [0..1] role ciudadCoche
end

association Revisado between
    Coche [1] role cocheRevision
    Revision [0..*] role revisionCoche
end

association Realizada between
    Taller [1] role tallerRevision
    Revision [0..*] role revisionTaller
end

association Viajado between
    Coche [1] role cocheViaje
    Viaje [0..*] role viajeCoche
end

association ViajeRecorrido between
    Recorrido [1] role recorridoViaje
    Viaje [0..*] role viajeRecorrido
end

-------------- End of relationships ------------------

------------- Invariants -------------

constraints
-------------------------
-- El formato para las invariantes será el siguiente:
-- context [CLASE]
  --- [ANOTACIONES ADICIONALES]
  -- [Número de apartado en enunciado]. [Frase explícita del enunciado]
  --- [ANOTACIONES ADICIONALES]
  --inv [nombre del invariante]
    -- [declaración del invariante]

-- Si tienes dudas, hay un ejemplo justo abajo
-------------------------

context Recorrido
  ---
  -- 1. Cada ciudad debe estar al menos a 5 kilómetros de distancia de otra. 
  ---
  inv DistanciaEntreCiudadesAlMenosCinco :
    self.numKm >= 5

context Revision
    ---
    -- 4. Todas las revisiones deben tener lugar después de que el coche se matriculase
    ---
    inv RevisionDespuesDeMatriculacion :
      self.cocheRevision.fechaMatriculacion < self.fechaInicio

context Ciudad
    ---
    -- 6. En cada ciudad habrá, a lo sumo, un taller oficial, pudiendo 
    -- haber varios talleres no oficiales. 
    --- se comprobará mirando si el taller es oficial, que solo exista uno
    inv UnSoloTallerOficial :
      self.tallerCiudad->select(t | t.oclIsTypeOf(TallerOficial))->size() <= 1 

context Viaje
    ---
    -- 8. Si el coche está realizando actualmente algún viaje, dicho
    -- viaje únicamente tendrá fecha de salida, pero no de llegada.
    ---
    inv ViajeEnCurso :
      self.cocheViaje.ciudadCoche.isUndefined() implies self.fechaLlegada.isUndefined()

context Coche
    ---
    -- 7. Si un coche está siendo sometido a una revisión, entonces el coche debe encontrarse en 
    -- la misma ciudad donde está el taller.
    ---
    inv CiudadCocheEnRevision_Igual_CiudadTaller :
      self.revisionCoche->isEmpty() or  -- no tiene revisiones
      self.revisionCoche->exists(r | r.fechaFin.isUndefined() implies self.ciudadCoche = r.tallerRevision.ciudadTaller) -- o si tiene, la revisión que está teniendo es en la misma ciudad
      -- si el exists no encuentra nada, da correcto (según ChatGPT)
    
    --- 
    -- 9. Un coche se encontrará en todo momento bien realizando un viaje determinado o bien en
    -- una ciudad.
    ---
    inv CocheEnViajeOCiudad :
      self.viajeCoche->isEmpty() implies self.ciudadCoche.isDefined() or  -- si nunca ha hecho un viaje, está en una ciudad
      self.viajeCoche->exists(v | v.fechaLlegada.isUndefined() implies self.ciudadCoche.isUndefined()) or -- si está haciendo un viaje, no está en una ciudad
      self.ciudadCoche.isDefined() implies not self.viajeCoche->exists(v | v.fechaLlegada.isUndefined()) -- si está en una ciudad, no está haciendo un viaje

      -- ANOTACIÓN DE IMPLEMENTACIÓN PREVIA: ESTÁ MAL
       -- con el let hacemos que si hay un undefined, se coloque al final
      --let viajesConLlegadaDefinida : OrderedSet(Viaje) = self.viajeCoche->sortedBy(r | r.fechaLlegada) in 
      --  ((viajesConLlegadaDefinida->isEmpty() or viajesConLlegadaDefinida->last().fechaLlegada.isDefined()) implies self.ciudadCoche.isDefined()) and
      --  ((viajesConLlegadaDefinida->last().fechaLlegada.isUndefined()) implies self.ciudadCoche.isUndefined())

    ---
    -- 10. Si el coche ha completado al menos un viaje y no se encuentra viajando, entonces debe
    -- encontrarse en la ciudad a la que llegó en su último viaje.
    ---
    inv CocheTerminaEnCiudad :
      self.viajeCoche->isEmpty() or   -- Tiene que dar correcto si ha completado 0 viajes
      not self.viajeCoche->exists(v | v.fechaLlegada.isUndefined()) implies 
      (self.ciudadCoche = self.viajeCoche->sortedBy(v | v.fechaLlegada)->last().recorridoViaje.ciudadFinal) 

      --(not(self.viajesRealizadosCoche->isEmpty()) and self.viajesRealizadosCoche->sortedBy(r | r.fechaLlegada)->last().fechaLlegada.isDefined()) implies 
      --(self.ciudadCoche = self.viajesRealizadosCoche->sortedBy(r | r.fechaLlegada)->last().recorridoViaje.ciudadFinal) 

    ---
    -- 11. Dos viajes no pueden solaparse en el tiempo, es decir, un viaje debe ocurrir siempre 
    -- después de otro, pudiendo la fecha de llegada de un viaje coincidir con la fecha de salida 
    -- del siguiente. 
    ---
    inv ViajesNoSeSolapan :
      let viajesOrdenados : OrderedSet(Viaje) = self.viajeCoche->sortedBy(v | v.fechaSalida) in
        (self.viajeCoche -> size() >= 2) implies 
        (self.viajeCoche-> forAll(v1,v2 | viajesOrdenados->indexOf(v1) = viajesOrdenados->indexOf(v2) - 1 implies 
                                                                        ((v1.fechaLlegada <= v2.fechaSalida))))
    
    -- Creo que esto está mal porque el forAll compara todos con todos, es decir, 
    -- compararía el primer elemento con el segundo y el segundo con el primero. En ese caso, el implies no se cumpliría

    --(self.viajesRealizadosCoche -> size() >= 2) implies 
    --  (self.viajesRealizadosCoche-> forAll(v1,v2 | v1 <> v2 implies ((v1.fechaLlegada <= v2.fechaSalida))))
    -- Esto comprueba del listado de viajes, con cada viaje, si se cumplen los invariantes bien
    -- de v1 comprueba con v2, v3,v4,v5,v6,v7... su fecha de fin sea anterior
    -- a la fecha de inicio del viaje v(i).
    -- v1 <> v2 evita duplicadas
    -- suponemos que los viajes estan ordenados, es decir, que v1 ocurre antes que v2

    ---
    -- 12. Las ciudades de origen y destino de los viajes deben ser coherentes. Es decir, si un coche 
    -- realiza un viaje desde la ciudad A hasta la ciudad B, el próximo viaje debe partir desde la ciudad B.
    --- NO SE COMO HACER PARA QUE ITERE DE UNO EN UNO, NO HAY UNA FUNCION INDEXOF Y SE LIA

    inv CiudadesCoherentes : 
      let viajesOrdenados : OrderedSet(Viaje) = self.viajeCoche->sortedBy(v | v.fechaSalida) in
        (self.viajeCoche -> size() >= 2) implies 
        (self.viajeCoche-> forAll(v1,v2 | viajesOrdenados->indexOf(v1) = viajesOrdenados->indexOf(v2) - 1 implies 
                            (v1.recorridoViaje.ciudadFinal = v2.recorridoViaje.ciudadOrigen)))

    -- inv ViajesNoSeSolapan:
    --  (self.viajeCoche -> size() >= 2) implies
    --    (self.viajeCoche
    --     ->sortedBy(r | r.fechaLlegada)
    --      ->forAll(i | 
    --        i <> self.viajeCoche->at(i+1) implies 
    --          (self.viajeCoche->at(i).recorridoViaje.ciudadFinal = self.viajeCoche->at(i+1).recorridoViaje.ciudadOrigen)
    --      )
    --   )

    ---
    -- 14. ESTO NO ES UN INVARIANTE, ES UNA ASUNCIÓN QUE SE HACE PARA FACILITAR EL MODELADO
    ---

    ---
    -- 15. ESTO NO ES UN INVARIANTE, ES EL DERIVE DE enGarantia
    ---

    ---
    -- 16. ESTO NO ES UN INVARIANTE, ES EL DERIVE DE necesitaMantenimiento
    ---
-------------- End of invariants ------------------

