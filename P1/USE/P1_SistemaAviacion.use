model SistemaAviacion
-------------- Enumerations ------------
-------------- Classes ------------------
class Aerolinea
    attributes
        nombre : String
end

class Avion
    attributes
        viajesCompletados : Integer derive : self.transporte->size()            -- No estoy seguro de si esta bien
        kmRecorridos : Real derive : self.transporte->collect(t|t.numKm)->sum() -- No estoy seguro de si esta bien
end

associationclass Contrato between 
        Avion [1..*] role contratado
        Aerolinea [1..*] role contratante
    attributes
        numMesesContrato : Integer
        precioMes : Real
        precioTotal : Real derive : self.precioMes * self.numMesesContrato --ESTO NO SE SI ESTÁ BIEN  
end

class Aeropuerto
    attributes
        --nombre : String 
        ciudad : String
end

class Almacen --  Los hangares y los desguaces tienen una capacidad máxima. No pone que sea la misma de aviones que pueden acoger, da igual es es un atributo heredado, a ver si estudiamos un poco...
    attributes
        capacidadMax : Integer
end 

-- Desguace hereda de almacén
class Desguace < Almacen
end 

-- Hangar hereda de almacén
class Hangar < Almacen
end 

class Persona
    attributes
        nombre : String
        edad : Integer
end

class Piloto < Persona
    attributes
        kmVolados : Real derive : -- no se si esta bien
            self.pilotaPrincipal->collect(v | v.numKm)->sum() + 
            self.pilotaSecundario->collect(v | v.numKm)->sum()
        esPro : Boolean
end

class Pasajero < Persona
end


class Vuelo 
    attributes
        identificador : Integer
        numKm : Real
end

-------------- Relationships ------------------
association AvionVuelo between
    Avion [1] role vehiculo
    Vuelo [0..*] role transporte
end

-- AvionAerolinea la modela la associationClass de Contrato

association AvionHangar between
    Hangar [0..1] role estanciaHangar
    Avion [0..*] role contenidoHangar
end

association AvionDesguace between
    Desguace [0..1] role estanciaDesguace
    Avion [0..*] role contenidoDesguace
end

composition hangarAeropuerto between
    Aeropuerto [1]
    Hangar [0..*]
end

composition desguaceAeropuerto between
    Aeropuerto [1]
    Desguace [0..1]
end

association PilotoPrincipalVuela between 
    Vuelo [0..*] role pilotaPrincipal -- un piloto, a lo largo de su vida, pilota varios vuelos
    Piloto [1] role esPilotadoPrincipal -- pero un vuelo es solo pilotado por un piloto
end

association PilotoSecundarioVuela between 
    Vuelo [0..*] role pilotaSecundario  -- un piloto, a lo largo de su vida, pilota varios vuelos
    Piloto [0..1] role esPilotadoSecundario -- pero un vuelo es solo pilotado por un piloto
end

association PasajeroVuelo between
    Pasajero [0..*] role transporta
    Vuelo [0..1] role viaja
end

------------- Invariants -------------
constraints

context Aerolinea

    -- 1. Cada Aerolínea tiene un nombre que debe ser distinto al de las demás => 
    -- Nombre de la Aerolínea es único
    ---
    inv NombreAerolineaDistinto :
        Aerolinea.allInstances()->isUnique(nombre)

context Avion
    
    -- 2. Todo Avión debe encontrarse volando, estacionado en un Hangar o ha sido ya relegado a un Desguace.
    ---
    -- esto ya esta implicito en el propio modelado, no? 
    -- Juanma: no se voy a intentar implementarlo pero el problema que hay aquí, 
    -- es que el avión mantiene un registro de los vuelos realizados
    -- entonces no pudes ver si el avión se encuentra actualmente volando.
    -- lo más mejorcillo que puedes hacer creo que es esto:
    inv avionEstado:
        self.tansporte -> notEmpty() or -- esto hace referencia si ha realizado algún vuelo, por eso está mal
        AvionHangar.allInstances()->exists(ha | ha.contenidoHangar = self) or -- esto pregunta si el avion esta en el hangar
        AvionDesguace.allInstances()->exists(de | de.contenidoDesguace = self) -- esto pregunta si el avion esta en el desguace



    ---
    -- 3. Los Aviones que deben encontrarse en un Desguace son aquellos que han completado los 1000 viajes.
    ---
    inv Avion1000ViajesVaDesguace : 
        self.viajesCompletados < 1000 or self.estanciaDesguace->isEmpty() -- no estoy seguro de si debo usar isEmpty pq no se si es una coleccion
        -- Juanma: creo que isEmpty se puede usar (segun chatgpt)

context Piloto

    ---
    -- 5. Cada PilotoPro debe tener al menos 1000 vuelos como Principal y 2000 como Secundario
    ---
    inv esPilotoPro:
        self.pilotaPrincipal->size() >= 1000 and self.pilotaSecundario->size() >= 2000 
    
    ---
    -- 6. No se permite a un piloto trabajar o haber trabajado para más de dos aerolíneas diferentes. 
    --inv maxDosAerolineas:
    --    let aerolineasPilotadas: Set(Aerolinea) = --Creo una variable, que es un conjunto de todos los viajes que ha hecho el piloto
    --        self.pilotaPrincipal.viaja->union(self.pilotaSecundario.viaja)->collect(v | v.vehiculo.contratado.contratante)->asSet() 
    --    in aerolineasPilotadas->size() <= 2
    -- esto es lo que nos dijo de quitar una relación y después trazarlo desde el otro camino usando el modelo de objetos (no tengo ni idea de cómo se hace)
    -- Juanma: esto es una calentada, debería habernos dejado hacer una relación más y yasta pero bueno
    -- según chatgpt esto está ok
    
context Aeropuerto
    ---
    -- 7. Cada Aeropuerto solo puede tener, como máximo, un Desguace (no dice nada sobre Hangares)
    inv soloUnDesguace:
        self.desguaceAeropuerto->size() <= 1
    --

    ---
    -- 8. Los aeropuertos se ubican en ciudades, no pudiendo haber más de un aeropuerto en cada ciudad => 
    -- Nombre de la ciudad del aeropuerto es único
    ---
    inv CiudadAeropuertoDistinta :
        Aeropuerto.allInstances()->isUnique(ciudad)

context Vuelo
    inv IdentificadorVueloDistinto :
        Vuelo.allInstances()->isUnique(identificador) 

    -- 9. Los pilotos principal y secundario deben ser personas distintas.
    inv pilotosDiferentes:
        self.pilotaSecundario.isEmpty() or self.pilotaPrincipal <> self.pilotaSecundario
    -- Juanma respuesta:
    -- La implementación es correcta, realmente el self.pilotaSecundario.isEmpty()
    -- no es necesario, pero si quereis mantenerlo por claridad y para entender 
    -- que el que puede estar ausente es el piloto secundario me parece bien
    