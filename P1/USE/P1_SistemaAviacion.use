model SistemaAviacion
-------------- Enumerations ------------
-------------- Classes ------------------
class Aerolinea
    attributes
        nombre : String
end

class Avion
    attributes
        viajesCompletados : Integer derive : self.vuelosAvion->size()            -- No estoy seguro de si esta bien
        kmRecorridos : Real derive : self.vuelosAvion->collect(t|t.numKm)->sum() -- No estoy seguro de si esta bien
end

associationclass Contrato between 
        Avion [1..*] role contratado
        Aerolinea [1..*] role contratante
    attributes
        numMesesContrato : Integer
        precioMes : Real
        precioTotal : Real derive : self.precioMes * self.numMesesContrato --ESTO NO SE SI ESTÁ BIEN  
end

class Aeropuerto
    attributes
        --nombre : String 
        ciudad : String
end

class Almacen --  Los hangares y los desguaces tienen una capacidad máxima. No pone que sea la misma de aviones que pueden acoger, da igual es es un atributo heredado, a ver si estudiamos un poco...
    attributes
        capacidadMax : Integer
end 

-- Desguace hereda de almacén
class Desguace < Almacen
end 

-- Hangar hereda de almacén
class Hangar < Almacen
end 

class Persona
    attributes
        nombre : String
        edad : Integer
end

class Piloto < Persona
    attributes
        kmVolados : Real derive : -- no se si esta bien
            self.vueloPrincipal->collect(v | v.numKm)->sum() + 
            self.vueloSecundario->collect(v | v.numKm)->sum()
        esPro : Boolean derive :
            self.vueloPrincipal->size() >= 1000 and self.vueloSecundario->size() >= 2000
end

class Pasajero < Persona
end


class Vuelo 
    attributes
        numKm : Real
end

-------------- Relationships ------------------
association Realiza between
    Avion [1] role vehiculo
    Vuelo [0..*] role vuelosAvion
end

-- AvionAerolinea la modela la associationClass de Contrato

association Estacionado between
    Avion [0..*] role almacenamientoHangar
    Hangar [0..1] role estanciaHangar
    
end

association Inutilizado between
    Avion [0..*] role almacenamientoDesguace
    Desguace [0..1] role estanciaDesguace
end

composition HangarAeropuerto between
    Aeropuerto [1]
    Hangar [0..*]
end

composition DesguaceAeropuerto between
    Aeropuerto [1]
    Desguace [0..1]
end

association PilotoPrincipalVuela between 
    Vuelo [0..*] role vueloPrincipal -- un piloto, a lo largo de su vida, pilota varios vuelos
    Piloto [1] role pilotoPrincipal -- pero un vuelo es solo pilotado por un piloto
end

association PilotoSecundarioVuela between 
    Vuelo [0..*] role vueloSecundario  -- un piloto, a lo largo de su vida, pilota varios vuelos
    Piloto [0..1] role pilotoSecundario -- pero un vuelo es solo pilotado por un piloto
end

association Transporta between
    Vuelo [0..1] role vuelosPasajeros
    Pasajero [0..*] role pasajeros
end

------------- Invariants -------------
constraints

context Aerolinea

    -- 1. Cada Aerolínea tiene un nombre que debe ser distinto al de las demás => 
    -- Nombre de la Aerolínea es único
    ---
    inv NombreAerolineaDistinto :
        Aerolinea.allInstances()->isUnique(nombre)

context Avion
    
    -- 2. Todo Avión debe encontrarse volando, estacionado en un Hangar o ha sido ya relegado a un Desguace.
    -- Es decir, no puede a la vez estar en un desguace y en un hangar, o volando y en un hangar, o volando y en un desguace...
    ---
    -- esto ya esta implicito en el propio modelado, no? 
    -- Juanma: no se voy a intentar implementarlo pero el problema que hay aquí, 
    -- es que el avión mantiene un registro de los vuelos realizados
    -- entonces no pudes ver si el avión se encuentra actualmente volando.
    -- lo más mejorcillo que puedes hacer creo que es esto:
   -- inv avionEstado:
    --    self.vuelosAvion -> notEmpty() or -- esto hace referencia si ha realizado algún vuelo, por eso está mal
    --   Estacionado.allInstances()->exists(ha | ha.almacenamientoHangar = self) or -- esto pregunta si el avion esta en el hangar
    --    Inutilizado.allInstances()->exists(de | de.almacenamientoDesguace = self) -- esto pregunta si el avion esta en el desguace



    ---
    -- 3. Los Aviones que deben encontrarse en un Desguace son aquellos que han completado los 1000 viajes.
    ---
    inv Avion1000ViajesVaDesguace : 
        self.viajesCompletados < 1000 or self.estanciaDesguace->isEmpty() -- no estoy seguro de si debo usar isEmpty pq no se si es una coleccion
        -- Juanma: creo que isEmpty se puede usar (segun chatgpt)

context Piloto

    ---
    -- 5. Cada PilotoPro debe tener al menos 1000 vuelos como Principal y 2000 como Secundario
    ---Juanma: esto no hay que ponerlo, ya se calcula solo con, al ser un atributo derivado

    
    -- ESTE INVARIANTE NO HACE NADA YA QUE EL ATRIBUTO BOOLEANO SE DERIVA CON EXACTAMENTE ESTA EXPRESION
    --inv esPilotoPro:
    --    self.vueloPrincipal->size() >= 1000 and self.vueloSecundario->size() >= 2000 
    


    ---
    -- 6. No se permite a un piloto trabajar o haber trabajado para más de dos aerolíneas diferentes. 
    --inv maxDosAerolineas:
    --    let aerolineasPilotadas: Set(Aerolinea) = --Creo una variable, que es un conjunto de todos los viajes que ha hecho el piloto
    --        self.vueloPrincipal.vuelosPasajeros->union(self.vueloSecundario.vuelosPasajeros)->collect(v | v.vehiculo.contratado.contratante)->asSet() 
    --    in aerolineasPilotadas->size() <= 2
    -- esto es lo que nos dijo de quitar una relación y después trazarlo desde el otro camino usando el modelo de objetos (no tengo ni idea de cómo se hace)
    -- Juanma: esto es una calentada, debería habernos dejado hacer una relación más y yasta pero bueno
    -- según chatgpt esto está ok
    
context Aeropuerto
    ---
    -- 7. Cada Aeropuerto solo puede tener, como máximo, un Desguace (no dice nada sobre Hangares) (Diría que esto no hace falta ponerlo porque está en la relación)
    --
    -- NO HACE FALTA MODELARLA, SE MODELA CON LA MULITPLICIDAD DE LA RELACIÓN

    ---
    -- 8. Los aeropuertos se ubican en ciudades, no pudiendo haber más de un aeropuerto en cada ciudad => 
    -- Nombre de la ciudad del aeropuerto es único
    ---
    inv CiudadAeropuertoDistinta :
        Aeropuerto.allInstances()->isUnique(ciudad)

context Vuelo

    -- 9. Los pilotos principal y secundario deben ser personas distintas.
    inv pilotosDiferentes:
        self.pilotoSecundario->isEmpty() or self.pilotoPrincipal <> self.pilotoSecundario
    -- Juanma respuesta:
    -- La implementación es correcta, realmente el self.vueloSecundario.isEmpty()
    -- no es necesario, pero si quereis mantenerlo por claridad y para entender 
    -- que el que puede estar ausente es el piloto secundario me parece bien